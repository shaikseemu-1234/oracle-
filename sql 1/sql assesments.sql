- count the no.of employees in each department
-- this query groups employees by department_id and counts how many employees exist in  each.
select department_id,count(*)as total_employees from hr.employees group by department_id;
select*from hr.employees
-- finding average salary in each department
select department_id,avg(salary) as average_salary from hr.employees group by department_id;
-- find the max sal and min sal in each department
select department_id,max(salary) as maximum_salary from hr.employees group by department_id;
select department_id,min(salary)as minimum_salary from hr.employees group by department_id;
-- find total salary in each department
select department_id,sum(salary) as total_salary from hr.employees group by department_id;
-- count the no.of employees in each job role
select job_id,count(*)as employees from hr.employees group by job_id
-- find the average salary for each job role
select job_id,avg(salary)as average_salary from hr.employees group by job_id;
-- find the max salary for each job role
select job_id,max(salary)as maximum_salary from hr.employees group by job_id;
-- total paid salary
select job_id,sum(salary)as total_salary from hr.employees group by job_id;
-- count the no.of employees hired in each year
select extract(year from hire_date)as hire_year,count(*) as total_employees from hr.employees group by extract(year from hire_date) order by hire_year;
select*from hr.employees
-- find teh total salary paid in each location
select d.location_id,sum(e.salary)as total_salary from employees e join departments d  on e.department_id=d.department_id  group by d.location_id;
-- find the no.of employees in each managers team
select manager_id,count(*) as team_member from hr.employees where manager_id is not null group by manager_id;
-- find the highest salary for each manager
select manager_id,max(salary)as max_salary from hr.employees where manager_id is not null group by manager_id;
-- find average salary for mnager team
select manager_id,avg(salary) as average_salary from hr.employees where manager_id is not null group by  manager_id;
-- find the departments with highest total salary
select department_id sum(salary)as total_salary from hr.employees
 group by department_id
 order by total_salary desc
  fetch first 1 row only;
-- find tehe job role with highest avg salary
select job_id,avg(salary)as average_salary from hr.employees group by job_id order by average_salary desc fetch first 1 row only ; 
-- find the no.of employees in each city
select l.city_id,count(*) as total_employees from hr.employees e join departments d on e.department_id=d.department_id group by l.city_id;
-- finding the no.of employees who have a commission ,grouped by department
select department_id,count(*) as employees _with_commission from hr.employees where commission_pct is not null group by department_id;
-- finding sum of salaris for employees who have a commission,grouped by department
select department_id,sum(salary)as total_salary_with_commission from  hr.employees where commission_pct is not null group by department_id;

-- oracle sql aggregate  questions for sales history table
select*from sh.sales
-- find no.of sales transaction for each product
select prod_id,count(*) as transaction_id from sh.sales group by prod_id
-- find average sale amount of each product
select prod_id,avg(amount_sold) as average_amount_sold from sh.sales group by prod_id 
-- find maximum sale amount of each product
select prod_id,max(amount_sold) as maximum_sales_amount_sold from sh.sales group by prod_id
-- find min sales amount of each product
select prod_id,min(amount_sold) as minimum_amount_sold from sh.sales group by prod_id
-- find the total revenue generated by each product
select prod_id,sum(amount_sold) as total_solds from sh.sales group by prod_id
-- count the no.of sales transaction for each customer
select cust_id,count(*) as sales from sh.sales group by cust_id
-- find the average sale amount per customer
select cust_id,avg(amount_sold) as avg_sales from sh.sales group by cust_id
-- find the highest purchase amount for each customer
select cust_id,max(amount_sold) as maximum_sales from sh.sales group by cust_id
-- find lowest purchase amount for each customer
select cust_id,min(amount_sold) as min_sales from sh.sales group by cust_id
-- find the total revenue generted by each store location
 select s.store_name,sum(s.amount_sold) as total_revenue from sh.sales s join sh.stores st on s.store_id=st.store_id group by s.store_name order by total_revenue desc
--  count the no.of sales transaction for each region
select cust_id,count(*)as transaction_sales from sh.sales group by cust_id order by transaction_sales desc;
-- find the total revenue per region
select prod_id,sum(amount_sold)as total_revenue from sh.sales group by prod_id;
-- find the average sale amount per region
select prod_id,avg(amount_sold) as average_revenue from sh.sales group by prod_id order by average_revenue desc;
-- no.of sales per month
select to_char(time_id,'mm')as month,count(*) as total_sales from sh.sales group by month order by month
-- total sales per month
select to_char(time_id,'mm') as month,sum(amount_sold) as total_sales from sh.sales group by month order by month
-- find the product that generated highest revenue

SELECT prod_name,total_revenue
FROM(
    select prod_name, 
    SUM(quantity_sold * amount_sold) AS total_revenue
FROM sh.sales s
JOIN sh.products p ON s.prod_id = p.prod_id
GROUP BY prod_name
ORDER BY total_revenue DESC ) temp_table
WHERE ROWNUM = 1;
select*from sh.products
-- find the mostly frequently purchased product
select prod_name,count(*)as purchase_sales from sh.products group by prod_name order by purchase_sales desc fetch first 1 row only;
-- most valuable customer based on total spending
select cust_id,sum(amount_sold)as total_invest from sh.sales group by cust_id order by total_invest desc fetch first 1 row only;
select*from sh.sales
-- find the total revenue per sales channel
select channel_id,sum(amount_sold)as total_revenue from sh.sales group by channel_id order by total_revenue desc
-- count the no.of sales for each payment method 
select quantity_sold,count(amount_sold) as sales_count from sh.sales group by quantity_sold 
-- queries for analytical functions
-- finding employees of salary within each department by using rank()
select employee_id,department_id,salary,rank()over (partition by department_id order by salary desc) as salary_rank from hr.employees
-- finding 3 highest paid employee on each department by using rank(
    select employee_id,department_id,salary_rank 
    from
    (
        select employee_id,department_id,salary,rank()over(partition by department_id order by salary desc)as salary_rank from hr.employees)
        where salary_rank<=3
select*from hr.employees
-- finding second highest salary in each department using dense_rank()
select department_id,employee_id,salary
FROM
(
    select department_id,employee_id,salary,dense_rank()over(partition by department_id order by salary desc)as salary_dense_rank from hr.employees where salary_dense_rank=2;
)
-- find the cummulative total salary of employees ordered by hire_date
select department_id,employee_id,salary,sum(salary)over(order by hire_date)as cummulative_salary from hr.employees
--assigning row number in each employee in each department
select department_id,employee_id,salary,row_number()over(partition by department_id order by employee_id)as row_num from hr.employees
-- find the salary diff b/w each employee and next highest paid employee
select employee_id,salary,lead(salary)over(order by salary desc) as salary_difference from hr.employees
-- by using lag we have to find the previous month salary of employee
select employee_id,salary,hire_date,lag(salary)over(partition by employee_id order by hire_date )as previous_sal from hr.employees
-- identify the employees whose salaries increased over time
select employee_id,hire_date,salary,lag(salary) over (partition by employee_id order by hire_date)as prev_salary,case when salary> lag(salary)over(partition by employee_id order by hire_date) then 'increased' else 'decreased' end as salary_trend from hr.employees;
-- joins queries
-- -- 1. Retrieve employee names and their department names using INNER JOIN
SELECT e.employee_id, e.first_name,e.last_name, d.department_name
FROM hr.employees e
INNER JOIN hr.departments d ON d.department_id = e.department_id;
select*from hr.departments
select*from hr.employees
-- 2. Retrieve all employees and their respective department names (including those without a department) using LEFT JOIN
SELECT e.employee_id, e.first_name,e.last_name, d.department_name
FROM hr.employees e
LEFT JOIN hr.departments d ON d.department_id = e.department_id;
-- 3. Retrieve all departments and employees (including departments without employees) using RIGHT JOIN
SELECT e.employee_id, e.first_name, d.department_name
FROM hr.employees e
RIGHT JOIN hr.departments d ON d.department_id = e.department_id;
-- 4. Retrieve all employees and their department names using FULL OUTER JOIN
SELECT e.employee_id, e.first_name, d.department_name
FROM hr.employees e
FULL OUTER JOIN hr.departments d ON d.department_id = e.department_id
-- 5. Retrieve employees who do not belong to any department using LEFT JOIN with NULL check
SELECT e.employee_id, e.first_name
FROM hr.employees e
LEFT JOIN hr.departments d ON d.department_id = e.department_id
WHERE d.department_id IS NULL;

-- 6. Retrieve departments that have no employees using RIGHT JOIN with NULL check
SELECT d.department_id, d.department_name
FROM hr.employees e
RIGHT JOIN hr.departments d ON d.department_id = e.department_id
WHERE e.employee_id IS NULL;
-- 7.Retrieve employees along with their manager names using SELF JOIN
SELECT e.employee_id, e.first_name, m.last_name AS manager_name
FROM hr.employees e
LEFT JOIN hr.employees m ON e.manager_id = m.employee_id;
-- 8. Retrieve employees along with their job title using INNER JOIN
SELECT e.employee_id, e.first_name, j.job_id
FROM hr.employees e
INNER JOIN hr.jobs j ON e.job_id = j.job_id;
-- 9. Retrieve employees along with the location of their department using INNER JOIN
SELECT e.employee_id, e.first_name, d.department_name, l.city

FROM hr.employees e
INNER JOIN hr.departments d ON e.department_id = d.department_id
INNER JOIN hr.locations l ON d.location_id = l.location_id;
-- 10. Retrieve employees and the project they are assigned to using INNER JOIN
SELECT e.employee_id, e.first_name, p.project_name
FROM hr.employees e
INNER JOIN projects p ON e.employee_id = e.employee_id;
select*from hr.departments
-- 11. Retrieve employees who have not been assigned to any project name using LEFT JOIN
SELECT e.employee_id, e.first_name,p.project_id
FROM hr.employees e
LEFT JOIN projects p ON  e.employee_id = e.employee_id
WHERE p.project_id IS NULL;
create table projects(
    project_id number primary key,
    project_name varchar2(255)not null,
    start_date date,
    end_date date,
    status varchar2(50)
)
select*from projects
INSERT INTO projects (project_id, project_name, start_date, end_date, status)  
VALUES (1, 'Website Redesign', TO_DATE('2024-03-01', 'YYYY-MM-DD'), TO_DATE('2024-06-30', 'YYYY-MM-DD'), 'In Progress');  

select*from projects
-- 12. Retrieve project names along with the department handling them using INNER JOIN
SELECT p.project_name, d.department_name
FROM projects p
INNER JOIN hr.departments d ON d.department_id = d.department_id
CREATE TABLE Training (
    TrainingID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    ProgramName VARCHAR2(255) NOT NULL,
    StartDate DATE NOT NULL,
    EndDate DATE NOT NULL,
    Trainer VARCHAR2(255),
    Location VARCHAR2(255),
    CreatedAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
INSERT INTO Training (ProgramName, StartDate, EndDate, Trainer, Location)  
VALUES ('Leadership Skills', TO_DATE('2025-04-01', 'YYYY-MM-DD'), TO_DATE('2025-04-10', 'YYYY-MM-DD'), 'John Doe', 'New York');

INSERT INTO Training (ProgramName, StartDate, EndDate, Trainer, Location)  
VALUES ('Data Analytics', TO_DATE('2025-05-15', 'YYYY-MM-DD'), TO_DATE('2025-05-25', 'YYYY-MM-DD'), 'Jane Smith', 'San Francisco');

INSERT INTO Training (ProgramName, StartDate, EndDate, Trainer, Location)  
VALUES ('Project Management', TO_DATE('2025-06-10', 'YYYY-MM-DD'), TO_DATE('2025-06-20', 'YYYY-MM-DD'), 'Mark Johnson', 'Chicago');
select *from training
-- 13. Retrieve employees along with the names of their training programs using INNER JOIN
SELECT e.employee_id, e.first_name, t.ProgramName
FROM hr.employees e
INNER JOIN training t ON t.TrainingID = t.TrainingID
-- 14. Retrieve employees who have not attended any training programs using LEFT JOIN
SELECT e.employee_id, e.first_name
FROM hr.employees e
LEFT JOIN training t ON t.TrainingID= t.TrainingID
WHERE t.TrainingID IS NULL;
CREATE TABLE Shift (
    ShiftID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    ShiftName VARCHAR2(100) NOT NULL,
    StartTime TIMESTAMP NOT NULL,
    EndTime TIMESTAMP NOT NULL,
    CreatedAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
INSERT INTO Shift (ShiftName, StartTime, EndTime)  
VALUES ('Morning Shift', TO_TIMESTAMP('2025-03-18 08:00:00', 'YYYY-MM-DD HH24:MI:SS'), 
        TO_TIMESTAMP('2025-03-18 16:00:00', 'YYYY-MM-DD HH24:MI:SS'));

INSERT INTO Shift (ShiftName, StartTime, EndTime)  
VALUES ('Evening Shift', TO_TIMESTAMP('2025-03-18 16:00:00', 'YYYY-MM-DD HH24:MI:SS'), 
        TO_TIMESTAMP('2025-03-18 00:00:00', 'YYYY-MM-DD HH24:MI:SS'));
select*from shift
-- 15. Retrieve employee names and their assigned shifts using INNER JOIN
SELECT e.employee_id, e.first_name, s.STARTTIME
FROM hr.employees e
INNER JOIN shift s ON s.SHIFTID= s.SHIFTID;
select*from hr.jobs
-- 16. Retrieve employees who do not have an assigned shift using LEFT JOIN
SELECT e.employee_id, e.first_name
FROM hr.employees e
LEFT JOIN shift s ON S.SHIFTID = s.SHIFTID
WHERE s.SHIFTID IS NULL;
-- 17. Retrieve employees, their department names, and their assigned project names using multiple INNER JOINs
SELECT e.employee_id, e.first_name, d.department_name, p.project_name
FROM hr.employees e
INNER JOIN hr.departments d ON e.department_id = d.department_id
INNER JOIN projects p ON e.employee_id = p.employee_id;
select*from projects
-- 18. Retrieve employees who have worked on more than one project using INNER JOIN and GROUP BY
SELECT e.employee_id, e.first_name, COUNT(p.project_id) AS project_count
FROM hr.employees e
INNER JOIN  projects p ON e.employee_id =e.employee_id
GROUP BY e.employee_id, e.first_name
HAVING COUNT(p.project_id) > 1;
--
create table department(
    department_name varchar2(50)not null,
    dept_budget number(10,2),
    department_id number(10)primary key);
)
INSERT INTO department(department_name,dept_budget,department_id,)
VALUES ('Human Resources',50000.00,1,);
INSERT INTO department(department_name,dept_budget,department_id,)
VALUES ('finance',70000.00,2,);

select*from department
-- 19. Retrieve employees along with their salaries and their department budget using INNER JOIN
SELECT e.employee_id, e.first_name, e.salary, dept_budget
FROM hr.employees e
INNER JOIN department d ON e.department_id = d.department_id;
-- 20. Retrieve employees who earn more than their department’s average salary using INNER JOIN and a subquery
SELECT e.employee_id, e.first_name, e.salary
FROM hr.employees e
INNER JOIN department d ON e.department_id = d.department_id
WHERE e.salary > (SELECT AVG(salary) FROM hr.employees WHERE department_id = e.department_id);
-- 21. Retrieve employees who have the same job role as another employee using SELF JOIN
SELECT e1.employee_id, e1.first_name, e2.first_name AS coworker_name, e1.job_id
FROM hr.employees e1
INNER JOIN hr.employees e2 ON e1.job_id = e2.job_id AND e1.employee_id <> e2.employee_id;
-- 22. Retrieve employees and their department names, but show "Not Assigned" if an employee has no department using LEFT JOIN and COALESCE
SELECT e.employee_id, e.first_name, COALESCE(d.department_name, 'Not Assigned') AS department_name
FROM hr.employees e
LEFT JOIN department d ON e.department_id = d.department_id
-- 23. Retrieve employees and their assigned projects, including employees who are not assigned to any project using FULL OUTER JOIN
SELECT e.employee_id, e.first_name,p.project_name
FROM hr.employees 
FULL OUTER JOIN projects ON p.employee_id = p.employee_id;
- 24. Retrieve employees who work in a city where their department is located using INNER JOIN
SELECT e.employee_id, e.first_name, d.l_city,d.location_id
FROM hr.employees e
INNER JOIN department d ON d.department_id = d.department_id
INNER JOIN hr.departments d ON location_id = location_id;
select*from department
select*from hr.employees
alter table department
add l_city varchar(150);
insert into department(l_city) values('bangalore');
UPDATE department  
SET l_city = 'hyderabad'  
WHERE department_id=2;
select*from department
alter table department
add bonus_amount number(10,2);
UPDATE department  
SET bonus_amount = 5000; 
WHERE department_id=1;
create table bonuses(
     employee_id number(10,2),
emp_name varchar2(150),
bonuse_amount number(10,2)
); 
insert into bonuses(employee_id,emp_name,bonuse_amount)values(1,'sarath',1000);
insert into bonuses(employee_id,emp_name,bonuse_amount)values(2,'sathwik',2000);
- 25. Retrieve employees and their total bonus amount using INNER JOIN with a bonus table
SELECT e.employee_id, e.first_name, SUM(b.bonuse_amount) AS total_bonus
FROM hr.employees e
INNER JOIN bonuses b ON e.employee_id = b.employee_id
GROUP BY e.employee_id, e.first_name;

-- 26. Retrieve employees who do not have any recorded bonuses using LEFT JOIN

-- 27. Retrieve employees and their department names where employees belong to a specific region using INNER JOIN
SELECT e.employee_id, e.first_name, d.department_name, r.region_name
FROM hr.employees e
INNER JOIN hr.departments d ON e.department_id = d.department_id
INNER JOIN hr.regions r ON r.region_id = r.region_id;
-- 28. Retrieve employees and their project details, even if they are not assigned to a project using LEFT JOIN
SELECT e.employee_id, e.first_name, p.project_name
FROM hr.employees e
LEFT JOIN projects p ON e.employee_id = e.employee_id
-- 29. Retrieve departments and the count of employees in each department using INNER JOIN and GROUP BY
SELECT d.department_id, d.department_name, COUNT(e.employee_id) AS employee_count
FROM department d
LEFT JOIN hr.employees e ON d.department_id = e.department_id
GROUP BY d.department_id, d.department_name;


-- 30. Retrieve employees who work on projects located in a different city than their department using INNER JOIN
SELECT e.employee_id, e.first_name,department_name, project_name, l_city AS project_city
FROM hr.employees e
INNER JOIN projects p ON e.employee_id = e.employee_id
INNER JOIN department d ON e.department_id = d.department_id
INNER JOIN hr.locations l ON l.location_id = l.location_id
WHERE l.location_id <> l.location_id;











 



    







